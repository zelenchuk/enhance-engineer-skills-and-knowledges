/*

 Полное текстовое описание задачи


1. Общая идея
Тебе нужно написать функцию, которая будет делить массив на части и сортировать их независимо друг от друга. В основе QuickSort лежит идея «разделяй и властвуй»:
- выбрать опорный элемент (pivot),
- разделить элементы относительно него,
- отсортировать получившиеся части тем же методом,
- соединить результат обратно.

2. Выбор опорного элемента
Каждый раз, когда функция вызывается, ты должен выбрать один элемент массива и назвать его pivot.
- Ты можешь выбрать первый элемент, последний, середину или случайный элемент.
- Для начала можно брать самый последний элемент, так проще.
- Pivot нужен, чтобы разделить массив на элементы «меньше него» и «больше него».

3. Разделение массива
Пройди по массиву и сравни каждый элемент с pivot:
- если элемент меньше pivot → отправь в массив less,
- если больше pivot → отправь в массив greater,
- если равен pivot, можно положить в отдельный список equal (обычно это сам pivot).

В итоге у тебя должно получиться три массива:
- less (все элементы меньше pivot),
- equal (pivot и такие же как pivot),
- greater (все элементы больше pivot).

4. Рекурсия
Теперь твоя функция должна сказать:
«Чтобы отсортировать исходный массив, я должен отсортировать сначала less, потом greater, а потом объединить их вместе с equal. Но сортировать я буду тем же самым методом QuickSort».

То есть:
- вызвать quickSort(less) → это вернёт отсортированный массив всех меньших элементов,
- вызвать quickSort(greater) → это вернёт отсортированный массив всех больших элементов,
- equal можно оставить как есть (оно уже упорядочено относительно pivot).

⚡ Важно: рекурсия должна останавливаться.
- Базовый случай: если в массиве меньше двух элементов (0 или 1), он уже отсортирован. Просто возвращаешь его как есть, без лишней логики.

5. Сборка результата
Когда у тебя готов результат рекурсии, ты должен их соединить в новый массив:

результат = отсортированный(less) + equal + отсортированный(greater)

Это и будет отсортированный массив.

6. Ограничения и проверка
- Функция должна работать с любым массивом чисел.
- Не использовать встроенные сортировки.
- Проверить на таких кейсах:
   [3, 1, 4, 1, 5, 9]
   [10, 9, 8, 7, 6]
   [1, 1, 1, 1]
   [] (пустой массив)
   [42] (один элемент).

7. Асимптотика
- Средний случай: O(n log n) (быстро).
- Худший случай: O(n^2) (если неудачно выбирать pivot, например, первый элемент на уже отсортированном массиве).
- Чтобы уменьшить риск худшего случая, можно выбирать pivot случайным образом.

8. Чек-лист для тебя
- Создай функцию quickSort(array).
- Напиши проверку: если массив короче 2 → возвращай как есть.
- Выбери pivot (например, последний элемент).
- Раздели массив на три части: меньше, равно, больше.
- Для less вызови quickSort(less).
- Для greater вызови quickSort(greater).
- Объедини результаты.
- Верни новый массив.



 ---

 Дополнительно:

 Math.floor(Math.random() * (размер_диапазона)) + начало_диапазона

 размер_диапазона - это тот самый range ... условно если у нас мин 0 а макс 2, то это кол-во эллементов в ряде: 0, 1, 2. Из этого получаеться, что если мы сделаем 2 - 0 = 2, но в ряду 3 числа, по-этому надо сделать +1

 */

const getRandomNumberByRange = (min, max) => {
  min = Math.ceil(min); // округляем вверх, если min дробный
  max = Math.floor(max); // округляем вниз, если max дробный
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

const rquickSort = (array, isUniqueOnly = false) => {
  if (array.length < 2) return array;
  const pivot = Math.floor(Math.random() * (array.length)); // because the pivot value must be an index in array, we are using full array length beuse it equal to randon range value
  let lessPart = [];
  let greaterPart = [];
  let i = 0;

  while(i < array.length){
    if (i === pivot) {
      i++;
      continue;
    }
    if (array[i] > array[pivot]) {
      greaterPart.push(array[i]);
    } else {
      lessPart.push(array[i]);
    }
    i++;
  }

  const result = [
    ...rquickSort(lessPart, isUniqueOnly),
    array[pivot],
    ...rquickSort(greaterPart, isUniqueOnly)
  ];

  return isUniqueOnly ? [...new Set(result)] : result;
}

console.log(rquickSort([]));
console.log(rquickSort([1]));
console.log(rquickSort([3, 1, 4, 1, 5, 9], true));
console.log(rquickSort([10, 9, 8, 7, 6]));
console.log(rquickSort([1, 1, 1, 1], true));
console.log(rquickSort([1,2,3,7,8,4,2,1,4], true));
